<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adding light - Learn luminance</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="crate-setup.html">Crate setup</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="chapter_1_2.html"><strong aria-hidden="true">1.2.</strong> Creating a window and preparing graphics code</a></li><li class="chapter-item expanded "><a href="chapter_1_3.html"><strong aria-hidden="true">1.3.</strong> Changing the background color</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Your first triangle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2_1.html"><strong aria-hidden="true">2.1.</strong> What is a triangle?</a></li><li class="chapter-item expanded "><a href="chapter_2_2.html"><strong aria-hidden="true">2.2.</strong> Shady triangle</a></li><li class="chapter-item expanded "><a href="chapter_2_3.html"><strong aria-hidden="true">2.3.</strong> Rendering our triangle</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Wavefront .obj loader</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3_1.html"><strong aria-hidden="true">3.1.</strong> The Wavefront .obj format</a></li><li class="chapter-item expanded "><a href="chapter_3_2.html"><strong aria-hidden="true">3.2.</strong> Defining our vertex type</a></li><li class="chapter-item expanded "><a href="chapter_3_3.html"><strong aria-hidden="true">3.3.</strong> Loading an .obj object</a></li><li class="chapter-item expanded "><a href="chapter_3_4.html"><strong aria-hidden="true">3.4.</strong> The shaders</a></li><li class="chapter-item expanded "><a href="chapter_3_5.html"><strong aria-hidden="true">3.5.</strong> Altering the graphics pipeline</a></li><li class="chapter-item expanded "><a href="chapter_3_6.html" class="active"><strong aria-hidden="true">3.6.</strong> Adding light</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Learn luminance</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#adding-light" id="adding-light">Adding light</a></h1>
<p>Light requires <a href="https://en.wikipedia.org/wiki/Normal_(geometry)">normals</a> to be able to compute the shading on surfaces. You might be used to it now:
if we need vertex normals, we need to change our vertex type definition.</p>
<h2><a class="header" href="#rethinking-our-vertex-type" id="rethinking-our-vertex-type">Rethinking our vertex type</a></h2>
<p>We need normals, so let’s just state it in our vertex type and semantics!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Semantics)]
pub enum VertexSemantics {
  #[sem(name = &quot;position&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexPosition&quot;)]
  Position,
  #[sem(name = &quot;normal&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexNormal&quot;)]
  Normal,
}

#[derive(Clone, Copy, Debug, Vertex)]
#[vertex(sem = &quot;VertexSemantics&quot;)]
struct Vertex {
  position: VertexPosition,
  normal: VertexNormal,
}
<span class="boring">}
</span></code></pre></pre>
<p>If you try to compile now, you will get an error such as the following:</p>
<pre><code>error[E0063]: missing field `normal` in initializer of `Vertex`
   --&gt; src/main.rs:102:26
    |
102 |             let vertex = Vertex { position };
    |                          ^^^^^^ missing `normal`
</code></pre>
<p>Ah, the beauty of strong-typing. :) Let’s fix our loader!</p>
<h2><a class="header" href="#adapting-the-loading-code" id="adapting-the-loading-code">Adapting the loading code</a></h2>
<p>Let’s take normals into account when loading objects:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for shape in geometry.shapes {
  if let obj::Primitive::Triangle(a, b, c) = shape.primitive {
    for key in &amp;[a, b, c] {
      if let Some(vertex_index) = vertex_cache.get(key) {
        indices.push(*vertex_index);
      } else {
        let p = object.vertices[key.0];
        let n = object.normals[key.2.ok_or(&quot;missing normal for a vertex&quot;.to_owned())?];
        let position = VertexPosition::new([p.x as f32, p.y as f32, p.z as f32]);
        let normal = VertexNormal::new([n.x as f32, n.y as f32, n.z as f32]);
        let vertex = Vertex { position, normal };
        let vertex_index = vertices.len() as VertexIndex;

        vertex_cache.insert(*key, vertex_index);
        vertices.push(vertex);
        indices.push(vertex_index);
      }
    }
  } else {
    return Err(&quot;unsupported non-triangle shape&quot;.to_owned());
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>The main change is this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = object.normals[key.2.ok_or(&quot;missing normal for a vertex&quot;.to_owned())?];
<span class="boring">}
</span></code></pre></pre>
<p>Basically, the obj format doesn’t force to use normals, so the normal index is optional. In our
case, we can enforce it this way or we could have a fallback normal that would point in the same
direction for all vertices. Up to you to decide.</p>
<h2><a class="header" href="#debugging-normals" id="debugging-normals">Debugging normals</a></h2>
<p>Let’s make a small and fun debug session to ensure our normals are okay. Modify the vertex and
fragment shader stages to forward the normals and display them.</p>
<pre><code class="language-glsl">// vertex shader
in vec3 position;
in vec3 normal;

out vec3 v_normal;

uniform mat4 projection;
uniform mat4 view;

void main() {
  v_normal = normal;
  gl_Position = projection * view * vec4(position, 1.);
}
</code></pre>
<pre><code class="language-glsl">// fragment shader
in vec3 v_normal;

// we will output a single color
out vec3 frag_color;

void main() {
  // KISS
  frag_color = v_normal;
}
</code></pre>
<p>Recompile and run. You should have something similar to this:</p>
<p><img src="imgs/suzanne_normals.png" alt="" /></p>
<p>How fancy! We can see several interesting things here:</p>
<ul>
<li>The top of the skull of Suzanne is mostly green. It makes sense because in those positions, the
vertex normals are roughly <code>(0, 1, 0)</code>, which when translated to RGB colors is mostly green.</li>
<li>The front face is mostly blue, which makes sense too as the normals there are around <code>(0, 0, 1)</code>,
which is blue in RGB encoding.</li>
<li>The left side (from Suzanne point of view) is mostly red, which makes sense too as it’s
<code>(1, 0, 0)</code> when encoded as RGB.</li>
<li>You can see that normals here are <em>smoothly</em> interpolated — i.e. you don’t actually see the triangles
that compose it. This is due to the fact the normals here were generated so that their directions
generate smooth interpolation across triangles. We could have used flat normals (i.e. face
normals) instead, or we could also explicitly tell the GPU not to perform interpolation in the
shaders. You can try it by using <code>flat out vec3 v_normal;</code> in the vertex shader and
<code>flat in vec3 v_normal;</code> in the fragment shader.</li>
</ul>
<p>Face normals here:</p>
<p><img src="imgs/suzanne_face_normals.png" alt="" /></p>
<h2><a class="header" href="#actually-lighting-the-mesh" id="actually-lighting-the-mesh">Actually lighting the mesh!</a></h2>
<p>Lighting is now a simple shader concept. Let’s implement a simple lighting effect based on
<a href="https://en.wikipedia.org/wiki/Shading#Directional_lighting">directional lighting</a>. Basically, we can
shade an object by computing the sine of the angles between the light rays and the object normal.
This is called diffused lighting and is an approximation that already gives good results.</p>
<p>The following code is based on the <a href="https://en.wikipedia.org/wiki/Phong_shading">Phong</a> illumination model. It’s basic and we know how to do
way better in terms of realism, but for our case, it’s more than enough.</p>
<pre><code class="language-glsl">in vec3 v_normal;

// we will output a single color
out vec3 frag_color;

void main() {
  // object color
  vec3 obj_color = vec3(.6, .6, .6);

  // light direction
  vec3 light_dir = vec3(0., -1., -.5);

  // diffusion factor (hence the k)
  float kd = dot(v_normal, -light_dir);

  frag_color = obj_color * kd;
}
</code></pre>
<p>And here’s the result:</p>
<p><img src="imgs/suzanne_lit.png" alt="" /></p>
<p>Complete code:</p>
<pre><pre class="playground"><code class="language-rust">use cgmath::{perspective, EuclideanSpace, Matrix4, Point3, Rad, Vector3};
use glfw::{Action, Context as _, Key, WindowEvent};
use luminance_derive::{Semantics, UniformInterface, Vertex};
use luminance_front::context::GraphicsContext;
use luminance_front::pipeline::PipelineState;
use luminance_front::render_state::RenderState;
use luminance_front::shader::Uniform;
use luminance_front::tess::{Interleaved, Mode, Tess, TessError};
use luminance_front::Backend;
use luminance_glfw::GlfwSurface;
use luminance_windowing::{WindowDim, WindowOpt};
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::Read as _;
use std::path::Path;
use std::process::exit;
use std::time::Instant;
use try_guard::verify;
use wavefront_obj::obj;

const VS_STR: &amp;str = include_str!(&quot;vs.glsl&quot;);
const FS_STR: &amp;str = include_str!(&quot;fs.glsl&quot;);

const FOVY: Rad&lt;f32&gt; = Rad(std::f32::consts::FRAC_PI_2);
const Z_NEAR: f32 = 0.1;
const Z_FAR: f32 = 10.;

#[derive(Debug, UniformInterface)]
struct ShaderInterface {
  #[uniform(unbound)]
  projection: Uniform&lt;[[f32; 4]; 4]&gt;,
  #[uniform(unbound)]
  view: Uniform&lt;[[f32; 4]; 4]&gt;,
}

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Semantics)]
pub enum VertexSemantics {
  #[sem(name = &quot;position&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexPosition&quot;)]
  Position,
  #[sem(name = &quot;normal&quot;, repr = &quot;[f32; 3]&quot;, wrapper = &quot;VertexNormal&quot;)]
  Normal,
}

#[derive(Clone, Copy, Debug, Vertex)]
#[vertex(sem = &quot;VertexSemantics&quot;)]
struct Vertex {
  position: VertexPosition,
  normal: VertexNormal,
}

type VertexIndex = u32;

struct Obj {
  vertices: Vec&lt;Vertex&gt;,
  indices: Vec&lt;VertexIndex&gt;,
}

impl Obj {
  fn to_tess&lt;C&gt;(
    self,
    surface: &amp;mut C,
  ) -&gt; Result&lt;Tess&lt;Vertex, VertexIndex, (), Interleaved&gt;, TessError&gt;
  where
    C: GraphicsContext&lt;Backend = Backend&gt;,
  {
    surface
      .new_tess()
      .set_mode(Mode::Triangle)
      .set_vertices(self.vertices)
      .set_indices(self.indices)
      .build()
  }

  fn load&lt;P&gt;(path: P) -&gt; Result&lt;Self, String&gt;
  where
    P: AsRef&lt;Path&gt;,
  {
    let file_content = {
      let mut file = File::open(path).map_err(|e| format!(&quot;cannot open file: {}&quot;, e))?;
      let mut content = String::new();
      file.read_to_string(&amp;mut content).unwrap();
      content
    };
    let obj_set = obj::parse(file_content).map_err(|e| format!(&quot;cannot parse: {:?}&quot;, e))?;
    let objects = obj_set.objects;

    verify!(objects.len() == 1).ok_or(&quot;expecting a single object&quot;.to_owned())?;

    let object = objects.into_iter().next().unwrap();

    verify!(object.geometry.len() == 1).ok_or(&quot;expecting a single geometry&quot;.to_owned())?;

    let geometry = object.geometry.into_iter().next().unwrap();

    println!(&quot;loading {}&quot;, object.name);
    println!(&quot;{} vertices&quot;, object.vertices.len());
    println!(&quot;{} shapes&quot;, geometry.shapes.len());

    // build up vertices; for this to work, we remove duplicated vertices by putting them in a
    // map associating the vertex with its ID
    let mut vertex_cache: HashMap&lt;obj::VTNIndex, VertexIndex&gt; = HashMap::new();
    let mut vertices: Vec&lt;Vertex&gt; = Vec::new();
    let mut indices: Vec&lt;VertexIndex&gt; = Vec::new();

    for shape in geometry.shapes {
      if let obj::Primitive::Triangle(a, b, c) = shape.primitive {
        for key in &amp;[a, b, c] {
          if let Some(vertex_index) = vertex_cache.get(key) {
            indices.push(*vertex_index);
          } else {
            let p = object.vertices[key.0];
            let n = object.normals[key.2.ok_or(&quot;missing normal for a vertex&quot;.to_owned())?];
            let position = VertexPosition::new([p.x as f32, p.y as f32, p.z as f32]);
            let normal = VertexNormal::new([n.x as f32, n.y as f32, n.z as f32]);
            let vertex = Vertex { position, normal };
            let vertex_index = vertices.len() as VertexIndex;

            vertex_cache.insert(*key, vertex_index);
            vertices.push(vertex);
            indices.push(vertex_index);
          }
        }
      } else {
        return Err(&quot;unsupported non-triangle shape&quot;.to_owned());
      }
    }

    Ok(Obj { vertices, indices })
  }
}

fn main() {
  let dim = WindowDim::Windowed {
    width: 960,
    height: 540,
  };
  let surface = GlfwSurface::new_gl33(&quot;Hello, world!&quot;, WindowOpt::default().set_dim(dim));

  match surface {
    Ok(surface) =&gt; {
      eprintln!(&quot;graphics surface created&quot;);
      main_loop(surface);
    }

    Err(e) =&gt; {
      eprintln!(&quot;cannot create graphics surface:\n{}&quot;, e);
      exit(1);
    }
  }
}

fn main_loop(mut surface: GlfwSurface) {
  let path = env::args()
    .skip(1)
    .next()
    .expect(&quot;first argument must be the path of the .obj file to view&quot;);
  println!(&quot;loading {}&quot;, path);

  let mesh = Obj::load(path).unwrap().to_tess(&amp;mut surface).unwrap();

  let start_t = Instant::now();

  let mut program = surface
    .new_shader_program::&lt;VertexSemantics, (), ShaderInterface&gt;()
    .from_strings(VS_STR, None, None, FS_STR)
    .unwrap()
    .ignore_warnings();

  let back_buffer = surface.back_buffer().unwrap();
  let [width, height] = back_buffer.size();
  let projection = perspective(FOVY, width as f32 / height as f32, Z_NEAR, Z_FAR);

  let view = Matrix4::&lt;f32&gt;::look_at(Point3::new(2., 2., 2.), Point3::origin(), Vector3::unit_y());

  'app: loop {
    // handle events
    surface.window.glfw.poll_events();
    for (_, event) in surface.events_rx.try_iter() {
      match event {
        WindowEvent::Close | WindowEvent::Key(Key::Escape, _, Action::Release, _) =&gt; break 'app,
        _ =&gt; (),
      }
    }

    // rendering code goes here
    // get the current time and create a color based on the time
    let t = start_t.elapsed().as_millis() as f32 * 1e-3;
    let color = [t.cos(), t.sin(), 0.5, 1.];

    let back_buffer = surface.back_buffer().unwrap();
    let render = surface.new_pipeline_gate().pipeline(
      &amp;back_buffer,
      &amp;PipelineState::default().set_clear_color(color),
      |_, mut shd_gate| {
        shd_gate.shade(&amp;mut program, |mut iface, uni, mut rdr_gate| {
          iface.set(&amp;uni.projection, projection.into());
          iface.set(&amp;uni.view, view.into());

          rdr_gate.render(&amp;RenderState::default(), |mut tess_gate| {
            tess_gate.render(&amp;mesh)
          })
        })
      },
    ).assume();

    // swap buffer chains
    if render.is_ok() {
      surface.window.swap_buffers();
    } else {
      break 'app;
    }
  }
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter_3_5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter_3_5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
