<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The shaders - Learn luminance</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="crate-setup.html">Crate setup</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="chapter_1_2.html"><strong aria-hidden="true">1.2.</strong> Creating a window and preparing graphics code</a></li><li class="chapter-item expanded "><a href="chapter_1_3.html"><strong aria-hidden="true">1.3.</strong> Changing the background color</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Your first triangle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2_1.html"><strong aria-hidden="true">2.1.</strong> What is a triangle?</a></li><li class="chapter-item expanded "><a href="chapter_2_2.html"><strong aria-hidden="true">2.2.</strong> Shady triangle</a></li><li class="chapter-item expanded "><a href="chapter_2_3.html"><strong aria-hidden="true">2.3.</strong> Rendering our triangle</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Wavefront .obj loader</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3_1.html"><strong aria-hidden="true">3.1.</strong> The Wavefront .obj format</a></li><li class="chapter-item expanded "><a href="chapter_3_2.html"><strong aria-hidden="true">3.2.</strong> Defining our vertex type</a></li><li class="chapter-item expanded "><a href="chapter_3_3.html"><strong aria-hidden="true">3.3.</strong> Loading an .obj object</a></li><li class="chapter-item expanded "><a href="chapter_3_4.html" class="active"><strong aria-hidden="true">3.4.</strong> The shaders</a></li><li class="chapter-item expanded "><a href="chapter_3_5.html"><strong aria-hidden="true">3.5.</strong> Altering the graphics pipeline</a></li><li class="chapter-item expanded "><a href="chapter_3_6.html"><strong aria-hidden="true">3.6.</strong> Adding light</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn luminance</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-shaders"><a class="header" href="#the-shaders">The shaders</a></h1>
<p>Again, we need to define our shaders. But in our case, we are going to need to write <em>slightly</em>
more complicated shaders. See, a 3D viewer requires objects to be <em>projected</em> onto one’s screen. In
the previous chapters, we just rendered a triangle in 2D. Here we are talking 3D. Going from a three
dimensional world to a screen (i.e. 2D) requires some operations to do.</p>
<h2 id="projection-matrix"><a class="header" href="#projection-matrix">Projection matrix</a></h2>
<p>Going from a 3D space to a 2D space always implies losing information on the fly in the process.
This is really easy to picture by taking an easier example. Imagine someone moving around Earth.
They have a position, including an altitude. Now imagine you want to <em>project</em> their positions onto
the up axis, giving the altitude at which those persons are. One very easy way to do that is to
simply <em>drop</em> all the other components of their positions and just retain their “up” component. For
instance, if we have a position as:</p>
<pre><code>position = (x, y, z)
</code></pre>
<p>And we say that <code>y</code> is the component of the up-axis, we can define our projection as such:</p>
<pre><code>project_altitude((_, y, _)) = y
</code></pre>
<p>Going from a 3D space to a screen can be done in <em>several</em> ways. The way done above was <em>3D -&gt; 1D</em>
but here, <em>3D -&gt; 2D</em> can be achieved by several ideas. For instance, an <em>orthogonal projection</em> is
a kind of projection that preserves parallels. A <em>perspective projection</em> is a projection that
implies distorting the vertices so that the <em>field of view</em> is respected. You are typically used to
that kind of projection when playing a video game or watching a movie, for instance. Or just taking
a picture!</p>
<h2 id="the-perspective-matrix"><a class="header" href="#the-perspective-matrix">The perspective matrix</a></h2>
<p>Any way, no more theory talk. In order to use a perspective matrix and project our loaded object,
we will be using the <a href="https://crates.io/crates/cgmath">cgmath</a> crate. Many exist that can do the job but I really like the simplicity
and raw speed of <a href="https://crates.io/crates/cgmath">cgmath</a>.</p>
<pre><code class="language-toml">cgmath = &quot;0.17&quot;
</code></pre>
<p>We will be using several symbols from it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cgmath::{perspective, EuclideanSpace, Matrix4, Point3, Rad, Vector3};
<span class="boring">}
</span></code></pre></pre>
<p>Don’t get scared about the heavy-math symbol names. What you must know, however, is this:</p>
<ul>
<li>In graphics applications, we use <a href="https://en.wikipedia.org/wiki/Linear_algebra">linear algebra</a> <em>a lot</em>. You don’t have to know everything by
heart, obviously, but having a linear algebra background will highly help for sure.</li>
<li>From linear algebra, we’re mostly interested into these concepts:
<ul>
<li>Vector spaces. The most important one. You should know how you are supposed to add vectors and
how to scale them by a given scalar number and how to compute the sine of the angle between two
vectors. More prerequisites will come but for today that’s enough about vector spaces.</li>
<li>Matrices. Unlike the movie, they’re not entertainment and can encode lots of other math
concepts, among linear maps and manipulating vector spaces in a compact and powerful way. We
use them for combining translations, scaling, rotations, <a href="https://en.wikipedia.org/wiki/Shear_matrix">shearing</a>, etc.</li>
<li>Quaternions. Scary name for a cute structure. Quaternions are 4-components numbers that can
represent a lot of things. In our case, we like to use them to represent arbitrary rotations of
φ angle (often expressed in radians) around a given unit axis (a unit axis is a 3D vector that
has been <a href="http://mathworld.wolfram.com/NormalizedVector.html">normalized</a> — i.e. its length is 1).</li>
</ul>
</li>
</ul>
<p>I know, I know, that’s a lot of new concepts completely unrelated to <a href="https://crates.io/crates/luminance">luminance</a>. But you need them
and, trust me, it’s not that hard.</p>
<p>Back to our code now.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOVY: Rad&lt;f32&gt; = Rad(std::f32::consts::FRAC_PI_2);
const Z_NEAR: f32 = 0.1;
const Z_FAR: f32 = 10.;

// …

// in the main_loop function, before the actual loop

let projection = perspective(FOVY, width as f32 / height as f32, Z_NEAR, Z_FAR);
<span class="boring">}
</span></code></pre></pre>
<p>This defines a projection matrix with a <em>field of view</em> set to <em>π ÷ 2</em> (wich represents a field of
view of 90°), with an <em>aspect ratio</em> defines by the division between the width and height of the
framebuffer we’re rendering into and with two special parameters, <code>Z_NEAR</code> and <code>Z_FAR</code>. Those are
<em>clipping</em> parameters defining a <em>frustrum</em> object. Everything outside the frustrum won’t be
visible when asking to render.</p>
<p><img src="https://i0.wp.com/www.lighthouse3d.com/wp-content/uploads/2011/04/vf.gif?w=405" alt="" /></p>
<blockquote>
<p>Image taken from <a href="http://www.lighthouse3d.com/tutorials/view-frustum-culling">here</a>.</p>
</blockquote>
<h2 id="the-view-matrix"><a class="header" href="#the-view-matrix">The view matrix</a></h2>
<p>A single projection matrix <em>projects</em> 3D coordinates on 2D coordinates with a given perspective but
the 3D coordinate system is still left unchanged. What it means is that projecting only will place
you in a situation where you’re still at the origin (i.e. <code>(0, 0, 0)</code>) looking in the <em>forward</em>
direction. What the forward vector is depends on which canonical system you decide to use, but in
our case, it’s a <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right-handed system</a>. The <em>X</em> unit axis goes from left to right of your screen;
the <em>Y</em> unit axis goes from down to up your screen and the <em>Z</em> axis (also called <em>depth</em>) goes from
<em>inside your screen</em> towards your face.</p>
<p>Because we will just place the loaded object at the origin, we will want to slightly offset our
position and view direction so that we can actually see the object. Again, <a href="https://crates.io/crates/cgmath">cgmath</a> provides us with
the right <em>transformation matrix</em> for this.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let view = Matrix4::&lt;f32&gt;::look_at(Point3::new(2., 2., 2.), Point3::origin(), Vector3::unit_y());
<span class="boring">}
</span></code></pre></pre>
<p>We will then be at the 3D point <code>(2, 2, 2)</code> and will look at the origin, the <em>Y</em> unit axis being
considered the <em>up</em> axis.</p>
<h2 id="declaring-the-matrices-in-the-shader"><a class="header" href="#declaring-the-matrices-in-the-shader">Declaring the matrices in the shader</a></h2>
<p>Next step is to actually use those matrices. In order to do so, we need to do two things:</p>
<ul>
<li>Use the matrices in the shader code.</li>
<li>Tell <a href="https://crates.io/crates/luminance">luminance</a> about the existence of those matrices in the shaders so that we can update them.</li>
</ul>
<h3 id="glsl-matrices"><a class="header" href="#glsl-matrices">GLSL matrices</a></h3>
<p>Let’s start from the <em>vertex shader</em> we used in the previous chapter.</p>
<pre><code class="language-glsl">// those are our vertex attributes
in vec2 position;
in vec3 color;

// this is the output of the vertex shader (we could have had several ones)
out vec3 v_color;

void main() {
  // simply forward the color
  v_color = color;

  // mandatory; tell the GPU to use the position vertex attribute to put the vertex in space
  gl_Position = vec4(position, 0., 1.);
}
</code></pre>
<p>In our case, we don’t have vertex colors anymore and we will likely just set a constant color to
start with. Plus, now the point is in 3D, not 2D.</p>
<pre><code class="language-glsl">in vec3 position; // 3D point!

void main() {
  gl_Position = vec4(position, 1.);
}
</code></pre>
<p>The problem is: it’s easy for the GPU to render 2D coordinates because there’s nothing to project:
your screen is already using a 2D space coordinate system. However, how should we handle our 3D
vertices?</p>
<p>You already have the answer: the <em>projection</em> matrix. That matrix will just turn your 3D vertices
into 2D vertices. In order to use it, you need to declare a <em>shader uniform variable</em>. Uniforms are
special variables which values are set by the application before or after a render command. When
a render command is issued, it is not possible to change the value anymore until the render command
has finished. You can picture those uniform values as <em>constants over a draw call</em>. Some graphics
APIs call those <em>constant buffers</em> for that reason.</p>
<p>Let’s add one we’ll call <code>projection</code>. You declare them at global scope, just next to <code>in</code> and
<code>out</code> declarations. They can be declared in any shader stage that needs to manipulate them.</p>
<pre><code class="language-glsl">uniform mat4 projection;
</code></pre>
<p>It’s as simple as that. In our case, <code>projection</code> is a 4×4 matrix that will be supplied by the
application.</p>
<p>In order to be projected, a point must be multiplied by a matrix. Let’s just project our 3D point
then:</p>
<pre><code class="language-glsl">gl_Position = projection * vec4(position, 1.);
</code></pre>
<p>All of this might be a bit weird or awkward at first because it’s highly linked to how vector spaces
and linear algebra work but you’ll have to trust me on this (or read some linear algebra theory!).</p>
<p>Now let’s add the <em>view</em> matrix, allowing us to slightly offset the camera in the scene:</p>
<pre><code class="language-glsl">uniform mat4 view;
</code></pre>
<p>Simple, right?</p>
<pre><code class="language-glsl">gl_Position = projection * view * vec4(position, 1.);
</code></pre>
<p>So, some explications here. We multiply <code>view</code> and <code>position</code> first because <code>view</code> is a matrix that
<em>transforms</em> a 3D point into another 3D point. You can picture that as a <em>basis transformation</em>.
Then we want to project that transformed point, so we multiply by the <code>projection</code> at the very left.</p>
<p>That’s all for the GLSL code. Nothing else to do: our 3D point is now projected onto our screen by
having gone through two basis change:</p>
<ul>
<li>A <em>3D -&gt; 3D</em> linear transformation to <em>move the camera around</em>.</li>
<li>A <em>3D -&gt; 2D</em> projection to introduce perspective.</li>
</ul>
<h3 id="the-uniform-interface"><a class="header" href="#the-uniform-interface">The uniform interface</a></h3>
<p>In order for your application to actually update and send those matrices to the GPU, you need to
declare them and change the way the shader <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> works. A special concept must be used here:
<a href="https://docs.rs/luminance/latest/luminance/shader/program/trait.UniformInterface.html">uniform interfaces</a>.</p>
<p>A uniform interface is a typed contract between the GLSL code compiled and linked in a shader
<a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> and what you are supposed to do with it. This powerful abstraction allows you to specify,
via a type, a set of <em>variables</em> that are available in the GLSL code and that you can get access to
as soon as your <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> gets shading things. The way you do this is a multi-step yet simple
process:</p>
<ol>
<li>You define a <code>struct</code> that holds the GPU variables. Those are called <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Uniform.html"><code>Uniform</code></a>.</li>
<li>You implement the <a href="https://docs.rs/luminance/latest/luminance/shader/program/trait.UniformInterface.html"><code>UniformInterface</code></a> trait for that type. If you don’t want to get too much
into the details of that trait, you can use <a href="https://crates.io/crates/luminance-derive">luminance-derive</a> to implement the trait very easily.
That’s what we are going to do.</li>
<li>You set your <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> type variable setting its <em>uniform interface</em> to the type you just
created.</li>
<li>When you use a <a href="https://docs.rs/luminance/latest/luminance/pipeline/struct.ShadingGate.html"><code>ShadingGate</code></a> to shade objects, you have access to your <em>uniform interface</em> and
can then update GPU variables there.</li>
</ol>
<p>Why cannot you create and handle the uniform interface by yourself? The thing is: that concept
<em>must</em> be <a href="https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance">contravariant</a>, because allowing you to handle such objects around while they depend on
the current GPU context and state would be highly unsafe.</p>
<p>Let’s create such a type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, UniformInterface)]
struct ShaderInterface {
  #[uniform(unbound)]
  projection: Uniform&lt;[[f32; 4]; 4]&gt;,
  #[uniform(unbound)]
  view: Uniform&lt;[[f32; 4]; 4]&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Sooo… as you can see, we define a regular <code>struct</code> but <em>derive</em> <a href="https://docs.rs/luminance/latest/luminance/shader/program/trait.UniformInterface.html"><code>UniformInterface</code></a>. Deriving the
trait unlocks several annotations you can use via the <code>#[uniform(..)]</code> syntax. Here, we’ll talk
about two:</p>
<ul>
<li><code>#[uniform(unbound)]</code>: that annotation tells luminance that <strong>if</strong> the GPU variable this uniform
variable refers to is <em>inactive</em> or <em>inexistent</em>, no error will be generated. Instead, a special
<em>unbound</em> uniform variable will be emitted. So an <em>unbound</em> <code>Uniform&lt;[[f32; 4]; 4]&gt;</code> means that if the GPU
variable named after that uniform is <em>inactive</em> or <em>inexistent</em>, the resulting <code>Uniform&lt;[[f32; 4]; 4]&gt;</code> will
silently do nothing when you will try to update it. This is a feature you want when you’re
developing or debugging but you should disable that on an end-user application or if you don’t
care about errors for a given variable.</li>
<li><code>#[uniform(name = &quot;foo&quot;)]</code>: rename the field. By default, the GLSL uniform variable will match the
name of the <code>struct</code> field you define. You can change the mapping with that simple annotation.</li>
<li>You can of course mix annotations; e.g. <code>#[uniform(name = &quot;t&quot;, unbound)]</code> is an <em>unbound</em> uniform
variable mapped to a <code>uniform float t</code> in the GLSL code.</li>
</ul>
<p>All we have to do now is to change the type of our <a href="https://docs.rs/luminance/latest/luminance/shader/program/struct.Program.html"><code>Program</code></a> to use the uniform interface and
we’re done.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let program = ctxt
    .new_shader_program::&lt;VertexSemantics, (), ShaderInterface&gt;()
    .from_strings(VS_STR, None, None, FS_STR)
    .unwrap()
    .ignore_warnings();
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_3_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter_3_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_3_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter_3_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
